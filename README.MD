<h1>DIO | Resumo parte 2 APIs e Entity Framework com .NET - Modulo 4</h1>

-> Aprender e desenvolver uma API, utilizando o Entity Framework para persist√™ncia de dados, juntamente com seus principais conceitos e funcionalidades.
<br>
[Digital Innovation One](https://www.dio.me/en)

## üìö Documenta√ß√£o 
- [Documenta√ß√£o .NET](https://git-scm.com/doc)
- [Documenta√ß√£o C#](https://docs.github.com/pt)

## üíª Resumos das Aulas

| Aulas | Resumos |
|-------|---------|
| Resumo sobre APIS e Entity Framework | [Resumos]() |


### API

-> Uma API (Application Programing Interface) √© uma forma de comunica√ß√£o entre computadores ou programas de computadores.

-> Basicamente um software que fornece informa√ß√µes para outro software.

-> APIs s√£o basicamente dados brutos.

-> Exemplo: Plataforma da DIO, acessando videos e recursos que est√£o no Youtube.

-> Exemplo cl√°ssico: um restaurante, voc√™ n√£o vai chegar para o cozinheiro e pedir a comida diretamente a ele, o papel dele √© cozinhar !

```
     Application = cliente   ->>  Gar√ßom = API  <<-  Server = cozinheiros
```
-> Entrada: Pedido que o cliente deseja.

-> Processamento: Ato de ir a cozinha pedir a solicita√ß√£o e retornar quando estiver pronto.

-> Saida: Concluiu a requisi√ß√£o/pedido.

-> Exemplo 2: Acesso a um site de compras, compra em um website, ele chama uma API que registra a venda e processamento no banco de dados, e ent√£o retorna para a API que ent√£o retorna para o cliente a resposta.

#### API de Feriados

-> Nager.Date: retorna lista de feriados de diversos pa√≠ses. [Site NagerDate](https://date.nager.at/)

-> Como aplicar: Digamos que tenha uma aplica√ß√£o, sistema que tenha o prazo de 3 dias √∫teis, queremos se saber se tem algum feriado nesses dias, caso tenha, adicionar mais um.

-> Pode ser feito manualmente no banco de dados e verificar as datas, por√©m existem feriados m√≥veis que nem sempre caem nos mesmo dias, nesse caso seria √∫till utilizar a API do NagerDate.

-> Dentro do site ele explica como fazer isto.

->> Muito importante ler a documenta√ß√£o de como utilizar a API, l√° √© dito como deve ser feita a requisi√ß√£o.

->> Resposta caso ele n√£o ache, Status: 404 (erro 404 - Not Found)

->> Outro erro caso troque os lugares de como devem ser passados os request pedidos, por exemplo, passar pa√≠s no lugar do ano 

#### Response

-> O que a API vai retornar, cada uma trabalha de maneira diferente e retorna de maneiras diferentes.

-> Resposta da API do NagerDate

| Dados | O que retornam |
|-------|----------------|
|date | The date of the holiday | 
|localName | Local name |
|name | English name | 
|countryCode | ISO 3166-1 alpha-2 |
|fixed | Is this public holiday every year on the same date |
|global	| Is this public holiday in every county (federal state) |
|counties | If it is not global you found here the Federal states (ISO-3166-2) |
|launchYear	| The launch year of the public holiday |
|types | The types of the public holiday, several possible <br>- Public <br>- Bank (Bank holiday, banks and offices are closed) <br>- School (School holiday, schools are closed) <br>- Authorities (Authorities are closed) <br>- Optional (Majority of people take a day off) <br> - Observance (Optional festivity, no paid day off)

Retorno:

```
[
   {
      "date": "2017-01-01",
      "localName": "Neujahr",
      "name": "New Year's Day",
      "countryCode": "AT",
      "fixed": true,
      "global": true,
      "counties": null,
      "launchYear": 1967,
      "types": [
         "Public"
      ]
   },
   {
      "date": "2017-01-06",
      "localName": "Heilige Drei K√∂nige",
      "name": "Epiphany",
      "countryCode": "AT",
      "fixed": true,
      "global": true,
      "counties": null,
      "launchYear": null,
      "types": [
         "Public"
      ]
   },
]   
```

-> Outro exemplo: Empresa de Ecommerce que vende os produtos e uma Empresa de transportes que vai levar o produto para o cliente final.

```
Empresa de Ecommerce  -->>  API de entregas  <<-- Empresa de Transportes
```
-> Empresa de transportes n√£o precisa saber sobre como foi feito o pagamento do cliente. S√≥ precisa de um comando da empresa de ecommerce, REQUISI√á√ÉO, para saber se deve entregar ou n√£o e o endere√ßo.

-> J√° a empresa de ecommerce precisa saber e informar ao cliente em quanto tempo o produto vai ser entregue, que precisa ser passado pela empresa de transportes .

-> O andamento do pedido por exemplo poderia ser passado pela nota fiscal ou n√∫mero de pedido, para consultar na base de dados dentro da empresa de transportes para saber onde est√° o pedido e ent√£o retornar a informa√ß√£o para a API que retorna para a empresa de ecommerce.

-> Para isso √© preciso de uma API para comunicar elas, de maneira autom√°tica.

#### Outro cen√°rio

-> Comunica√ß√£o entre Frontend, Backend e Banco de dados.

```
 Frontend -->>  Backend  <<-- Banco de dados
```

-> Situa√ß√£o: um site de uma empresa que pode ser acessado s√≥ por funcion√°rios da pr√≥pria empresa para realizar cadastro de algumas informa√ß√µes, sem ser exposta externamente.

-> Ou seja, APIs tamb√©m servem para comunica√ß√ïes em sistemas fechados dentro de uma mesma empresa.

#### API de Imagens de Cachorros

-> Dog API: maior cole√ß√£o de imagens livres de uso de cachorros. [Site DogAPI](https://dog.ceo/dog-api/)

Retorno dela:

```
{
    "message": "https://images.dog.ceo/breeds/pomeranian/n02112018_2314.jpg",
    "status": "success"
}
```

#### Criando uma API

-> dotnet new webapi-> cria preparo para uma API

-> dotnet watch run -> toda opera√ß√£o feita n√£o precisa ser parada e rodar de novo, ele fica observando os arquivos da api e caso identifique alguma mudan√ßa ele vai recompilar automaticamente.

-> Ou seja n√£o precisa parar e executar de novo.

-> Ele cria autom√°tico um exemplo de hello world de API (api de tempo).

-> Caso seja parada a execu√ß√£o ele pergunta se deve voltar (responder com Y ou N)

-> Depois de criada classe UsuarioController (ver c√≥digo), e atualizar, ele j√° pode ser chamado pela WebAPI e j√° aparece no Swagger.

### Documentar APIs

-> Swagger: conceito do .NET que servve para documentar uma API, serve para desenvolvedores testarem a API.

-> Ele √© opcional, √© uma ferramente que auxilia na documenta√ß√£o e teste, serve para facilitar a vida.

-> API criada localmente (localhost).

#### Controller

-> Uma classe que vai agrupar suas requisi√ß√µes HTTP e disponibilizar seus endpoints.

-> Agrupar todas as a√ß√µes em comum, classes em comum e colocar na Controller.

-> Exemplo: Vamos supor que se tem uma API que atualiza os usu√°rios, cria-se ent√£o o usuario.controller, e tudo que
fizer na usu√°rios, como busca por id, atualizar usu√°rio, deletar usu√°rio, ser√° atualizado na usuario.controller.

-> Para uma atualiza√ß√£o de digamos produto, ai ser√° criada outra controller, produto.controller.

#### Entendendo as Rotas

-> Controllers √© pasta de entrada principal da API.

-> Parte controller √© ignorada no nome, mas serve para identificar um padr√£o que ser√£o identificadas na API, o caminho dela e no Swagger.

-> Exemplo desse caminho: Classe usuario -> 'https://localhost:7069/Usuario/ObterDataHoraAtual'

-> Nome que aparece do m√©todo disponibilizado: Perceber que o nome √© diferente do m√©todo criado ObterDataHora() [HttpGet("ObterDataHoraAtual")], pois eles podem ser diferentes.


### Entity Framework

-> √â um framework ORM (Object-Relational Mapping) criado para facilitar a integra√ß√£o com o banco de dados, mapeando tabelas e gerando comandos SQL de forma autom√°tica.

-> At√© agora trabalhamos com dados em mem√≥ria, que ao fechar os dados eram perdidos, mas agora √© preciso que tenha a persist√™ncia desses dados.

-> Salvar um usu√°rio, inserindo em uma API, e salva-lo em uma tabela dentro de um banco de dados.

-> Passar um comando para o C# para ent√£o ser executado no banco de dados.

-> O entity framework √© capaz de abstrair toda a comunica√ß√£o e gera√ß√£o do SQL a partir do C#, de forma automatica.

```
                          User Interface (UI)
                                |                          
                               /|\ 
                          BusinesseLayer     -> camada de neg√≥cios, classes, controller, onde recebe e trata dados
                                |
                               /|\
                          DataLayer (Entity Framework) -> camada mais pr√≥xima do banco de dados.
                                |
                               /|\
                            Database         
```

-> Ou seja, teremos uma classe por exemplo, usuario em meu programa, e uma tabela chamada usuario no banco de dados, e para elas se comunicarem ser√° feito pelo entity framework.

-> Digamos que precisamos selecionar um usu√°rio do banco (comando SELECT Nome FROM usuario), n√£o precisa ser escrito um comando para isso, a ferramente j√° executa.

-> Em resumo, n√£o precisamos nos preocupar com as querys a serem feitas no banco de dados, bastante facilitada pelo Entity Framework.

### CRUD

-> C = CREATE (Insert)

-> R = READ (Select)

-> U = UPDATE (Update)

-> D = DELETE (Delete)

->> Opera√ß√µes para trabalhar com banco de dados, CRUD √© usado ao trabalhar com banco de dados

O que o Entity faz?

```
 Contatos                                              CREATE TABLE Contatos... 
 + Id: int                   Entity framework          INSERT INTO Contatos...              
 + Nome: string                  ----->>>              UPDATE Contatos...
 + Telefone: string                                    SELECT * FROM Contatos...
 + Ativo: bool                                         DELETE FROM Contatos...
```

-> Ao solicitar ou realizar algo no Entity framework ele vai traduzir para o SQL.

-> Exemplo: criada nova classe Contatos no programa, podemos usar o entity para criar uma tabela com nome tamb√©m Contatos no banco de dados, poupando muito tempo de desenvolvimento. 

-> Parte ruim: pouca pr√°tica dos comandos SQL na veia.

#### Instalar ferramenta do Entity framework

-> Instalar apenas um vez, a partir dai, outros projetos j√° ter√£o o entity instalado.

-> Ficar atento a vers√£o, devido a estar usando o .NET 6.

```
dotnet tool install --global dotnet-ef --version 6.0.6
```
-> Chamar a ferramenta atrav√©s do dotnet-ef

->> Instalar pacote Design
```
dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.6
```
-> Pacote instalado a n√≠vel de projeto, precisa executar para todos os projetos

->> Instalar pacote do servidor desejado, no caso SqlServer
```
dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 6.0.6 
```

#### Criando Classe chamada Contato

-> Objetivo √© fazer um CRUD de contatos, semelhante a uma agenda.

-> Criar classe chamada Contatos (ver c√≥digo), de resto o entity framework resolve.

->>>> IMPORTANTE: esta classe √© uma entidade, toda entidade √© uma classe que ir√° virar uma tabela no banco de dados.

#### Criando Contexto

-> Classe que centraliza todas as nossas informa√ß√µes em um banco de dados.

-> Criada AgendaContext, nome do database vai ser Agenda.

#### Cadastrando Conex√£o e Iniciando DbContext

-> Pastas appsettings.json, Conex√£o ser√° cadastrada nessas pastas !!!.

-> appsettings.Development = usa s√≥ para teste, desenvolvimento.

-> appsettings.json = usado para produ√ß√£o, para implementar em um ambiente real.

-> Exemplo pr√°tico: Podemos indicar que quando estivermos no ambiente de desenvolvimento n√£o vamos enviar email aos usu√°rios, mas em produ√ß√£o ele ir√° enviar.

```
"EnviaEmail": false    -> Criado nos Json para exemplo
```

->>> Criar conex√£o, lembrar de iniciar banco de dados
```
"ConnectionStrings": {
    "ConexaoPadrao": "Server=localhost\\sqlexpress;Initial Catalog=Agenda; Integrated Security=True"
  }
  
Entendendo: "Server=localhost\\sqlexpress"  -> endere√ßo do server
Initial Catalog=Agenda     -> Entity framework vai criar o banco de dados que ainda n√£o existe
Integrated Security=True   -> Autentica√ß√£o sendo feita apenas pelo usu√°rio do windows, j√° que estamos localmente
                              numa situa√ß√£o de produ√ß√£o seria aqui que passariamos login e senha   
```
-> Lembrando que a conex√£o acima pode variar a depender de local do banco, qual banco sendo utilizado.

-> Agora precisamos configurar o nosso context passando a string de conex√£o, para ele conseguir utilizar ela.

```
Abrir classe program.cs e adicionar c√≥digo abaixo

builder.Services.AddDbContext<AgendaContext>(options => options.UseSqlServer(builder.Configuration.GetConnectionString("ConexaoPadrao")));

Entendendo: AddDbContext<AgendaContext>   -> Adicionando o database do tipo AgendaContext
options => options.UseSqlServer      -> Passando algumas opcoes, para usar o SqlServer
builder.Configuration                -> Pegando configuracao do appsettings
GetConnectionString                  -> Pegando alguma chave da connectionString no caso a "ConexaoPadrao" que foi
                                        criada

builder.Services.AddDbContext<AgendaContext>(options => options.UseSqlServer("Server=localhost\\sqlexpress;Initial Catalog=Agenda; Integrated Security=True"));                    

-> Poderia ser feita desse jeito tambem, mas nao √© recomendado, pois se precisar mudar ter√° que recompilar o programa, e desse jeito teria que est√° recompilando toda vez.
```

#### Migrations

-> Apesar do entity gerar os comandos da tabela de forma automatica, precisamos dizer ao entity que existem altera√ß√µes no c√≥digo que precisam ser refletidas no banco de dados.

-> Toda cria√ß√£o de tabela √© necess√°rio pedir ao entity para criar de maneira antecipada, chamada de migrations.

-> Migrations √© basicamente um mapeamento feito pelo entity das classes para poder transformar elas eme tabelas.

-> Hora de usar o banco de dados, lembrar de usar ele.

```
dotnet-ef migrations add CriacaoTabelaContato    -> Nome √© bom ser descritivo, pode ser qualquer um.

para remover:  dotnet ef migrations remove
```

-> Pasta chamada Migrations criada, aparecendo a data que foi criada.

-> Importante notar que as munda√ßas ainda n√£o est√£o no banco de dados.

-> Execu√ß√£o:
```
dotnet-ef database update          -> Aplicando mudan√ßas
```

-> Depois de uma dor de cabe√ßa devido a permiss√£o de adminstrador, consegui fazer rodar indo na pasta security e alterando permiss√µes de cria√ß√£o e acesso.

-> Criado database Agenda no banco de dados, com tabela contatos, e uma tabela MigrationHistory que n√£o deve ser mexida, ir√° apenas armazenar o hist√≥rico para n√£o repetir a√ß√µes, como tentar criar de novo.

#### Criando a Controller e os Endpoints 

-> Objetivo agora √© botar um CRUD na tabela de Contato.

-> Enviando uma informa√ß√£o: [HttpPost] poderia passar algo mas n√£o precisa.

-> Executar dotnet watch run

-> Para fazer um POST √© necess√°rio passar o request body, formato json.

-> No terminal aparece o que ele fez, depois de realizar o POST, realizado pelo pr√≥prio entity framework.

-> Informa√ß√µes j√° inseridas no database.

->> Lembrar que os endpoints s√£o os m√©todos que realizam as a√ß√µes !!!

Criando endpoint de CREATE para realizar um POST, ou seja, um INSERT INTO de dados na tabela.
```
  private readonly AgendaContext _context;
        public ContatoController(AgendaContext context)
        {
            // construtor
            _context = context;
        } 
         
        [HttpPost] 
        public IActionResult Create(Contato contato)
        {
            _context.Add(contato);
            _context.SaveChanges();
            return Ok(contato);
        }
```
Continuando...

Criando endpoint READ, ou seja, um GET para o Id, tudo na ContatoController, basicamente um SELECT.
```
[HttpGet("{id}")]
public IActionResult ObterPorId(int id)
        {
            // Contatos representa nosso dbcontext
            var contato = _context.Contatos.Find(id);

            if (contato == null)
            {
                return NotFound();          -> title caso n√£o encontre.
            }  

            return Ok(contato);
        }
```

Criando o endpoint de Update, m√©todo vai receber um id do contato que queremos atualizar, e recebe um contato, que √© o json das informa√ß√ïes que queremos que sejam atualizadas.

Realizado UPDATE na tabela do banco de dados.
```
[HttpPut("{id}")]
        public IActionResult Atualizar(int id, Contato contato)
        {
            var contatoBanco = _context.Contatos.Find(id);

            if (contatoBanco == null)
            {
                return NotFound();
            }

            contatoBanco.Nome = contato.Nome;
            contatoBanco.Telefone = contato.Telefone;   -> Basicamente pegando as informa√ß√µes que estao no banco
            contatoBanco.Ativo = contato.Ativo;           e atualizando pelas informa√ß√µes novas a serem postas.

            _context.Contatos.Update(contatoBanco);     -> atualizando propriamente o contato do banco.
            _context.SaveChanges();

            return Ok(contatoBanco);
        }
``` 
->> Utilizar Swagger para ver altera√ß√µes.

Criando endpoint de DELETAR, retorno 204 significa sucesso mas que n√£o retorna nada, j√° que ele foi deletado.

```
[HttpDelete("{id}")]
        public IActionResult Deletar(int id)
        {
            var contatoBanco = _context.Contatos.Find(id);

            if (contatoBanco == null)
            {
                return NotFound();
            }

            _context.Contatos.Remove(contatoBanco);
            _context.SaveChanges();                  -> lembrar do saveChanges se n√£o ele n√£o salva l√° no banco
            return NoContent();
        }
```
CRUD COMPLETO !!!

#### Agora vamos incrementar nosso m√©todo GET.

->> Podemos criar v√°rios endpoints, para realizar difetens a√ß√µes

Criando endpoint de obter por Nome, novo m√©todo GET, para permitir que ele filtre por Id e tamb√©m por nome.

-->> Podemos criar v√°rias maneiras de busca, inclusive passando mais de um par√¢metro, inclusive fazendo eles sendo opcionais, passar um ou outro j√° traria o resultado.
``` 
[HttpGet("ObterPorNome")]
        public IActionResult ObterPorNome(string nome)
        {
            var contatos = _context.Contatos.Where(x => x.Nome.Contains(nome));
            return Ok(contatos);
        }
```

### Verbos HTTP

-> A√ß√µes que iriam ocorrer na API.

| HTTP Verb | CRUD | O que faz |
|-----------|------|-----------|
| POST | Create | Postando/Criando nova informa√ß√£o na API|
| GET | Read | Obter informa√ß√µes, relacionado com retorno da informa√ß√£o|
| PUT | Update/Replace | Atualiza informa√ß√µes, precisando passar tudo (Nome, telefone, Ativo)|
| PATCH | Update/MOdify | Semelhante ao PUT, por√©m n√£o precisa passar informa√ß√£o completa|
| DELETE | Delete | Deletar informa√ß√µes desejadas| 

#### Recapitulando a constru√ß√£o da API

-> Lembrar da instala√ß√£o dos pacotes, lembrar da vers√£o, e de que preicisam ser instalados toda vez a n√≠vel de projeto.

-> Cria√ß√£o da conex√£o nas pastas appsettings (meu caso s√≥ na de desenvolvimento).

Precisa ter nome ConnectionStrings !!!
```
"ConnectionStrings": {
    "ConexaoPadrao": "Server=localhost\\sqlexpress; Initial Catalog=Agenda; Integrated Security=True"
  }
```

-> Criada pasta entities, que representa uma classe que tamb√©m ir√° ser uma tabela no banco de dados.

-> Criado Context, que herda de DbContext, classe que vai acessar o banco de dados, precisa do construtor rebendo um options, e passando para classe dbcontext ( : base(options))

-> Dbset do tipo Contato, chamado de Contatos, que serve para acessar os registros da tabela Contatos chamando essa mesma propriedade.

-> Se n√£o estiver no Dbset n√£o ser√° identificada com tabela.

-> Program.cs para passar a configura√ß√£o para o dbconext, conex√£o do banco de dados para se conectar.
```
// Add services to the container.
builder.Services.AddDbContext<AgendaContext>(options => options.UseSqlServer(builder.Configuration.GetConnectionString("ConexaoPadrao")));

->> options recebido na AgendaContext para acessar o servidor
->> "ConexaoPadrao" √© a conexao cadastrada no JSON.
```

-> Criadas migrations, que √© o c√≥digo para espelhar as altera√ß√µes no c√≥digo dentro do banco de dados.

-> N√£o precisamos alterar, s√≥ validar as munda√ßas.

-> Mesmo criada a migration ela ainda n√£o foi aplicada no database.
```
dotnet-ef migrations add CriacaoTabelaContato  
dotnet-ef database update
```

-> As controllers, ponto de entrada onde se disponibiliza os m√©todos (endpoints)

-> Heran√ßa de ControllerBase.

-> Receber via construtor o AgendaContext que nos permite acessar o banco de dados. Chamado de inje√ß√£o de depend√™ncia.
```
[ApiController]
[Route("[controller]")] 

private readonly AgendaContext _context;
        public ContatoController(AgendaContext context)
        {
            // construtor
            _context = context;
        } 
```

-> Por √∫ltimo cria√ß√£o do CRUD, m√©todos/endpoints, para todos precisamos chamar o SaveChanges, com exce√ß√£o do GET.

-> Utilizar o Swagger !!!.

#### Alterando endpoint Create


-> Trocar m√©todo OK para CreateAtAction().
```
return CreatedAtAction(nameof(ObterPorId), new { id = contato.Id }, contato);

-->> Ap√≥s criar, para obter o registro rec√©m criado, chame o ObterPorId e retorne o id rec√©m criado ({ id = contato.Id }) e a pr√≥pria informa√ß√£o do contato.

-> Isso para retornar um location, mostrando que foi criado e mostrando o recurso (https://localhost:7069/Contato/6)
```
  


